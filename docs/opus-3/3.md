# Core Library Deep Dive: Integrated Analysis

I have thoroughly reviewed the **PowerPoint Agent Core Programming Handbook (v3.1.4)** and integrated it with my existing understanding. This analysis captures the critical implementation details, internal mechanisms, and operational patterns that govern the core library.

---

## ğŸ“‹ Document Integration Summary

| Document | Integration Focus |
|----------|------------------|
| Previous: Architecture & Design | High-level patterns, tool ecosystem |
| Previous: Agent System Prompt | Workflow phases, governance principles |
| Previous: Tool Development Guide | CLI wrapper patterns, templates |
| **New: Core Handbook v3.1.4** | **Internal implementation, API specifics, performance, XML magic** |

---

# Part I: Core Library Architecture (Deep Understanding)

## 1.1 The PowerPointAgent Class â€” Role & Responsibilities

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PowerPointAgent: The Central Hub                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  LAYER 1: File Safety                                                â”‚   â”‚
â”‚   â”‚  â€¢ Context manager pattern (with statement)                          â”‚   â”‚
â”‚   â”‚  â€¢ Atomic file locking (os.open with O_CREAT|O_EXCL)                â”‚   â”‚
â”‚   â”‚  â€¢ 10-second lock timeout                                            â”‚   â”‚
â”‚   â”‚  â€¢ Path validation (traversal protection, extension check)           â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                     â”‚                                        â”‚
â”‚                                     â–¼                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  LAYER 2: State Observability                                        â”‚   â”‚
â”‚   â”‚  â€¢ SHA-256 version hashing (geometry + content)                      â”‚   â”‚
â”‚   â”‚  â€¢ Before/after version tracking for all mutations                   â”‚   â”‚
â”‚   â”‚  â€¢ Conflict detection for multi-agent workflows                      â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                     â”‚                                        â”‚
â”‚                                     â–¼                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  LAYER 3: Governance Enforcement                                     â”‚   â”‚
â”‚   â”‚  â€¢ Approval tokens for destructive operations                        â”‚   â”‚
â”‚   â”‚  â€¢ HMAC-SHA256 token validation                                      â”‚   â”‚
â”‚   â”‚  â€¢ Scope-based permission checking                                   â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                     â”‚                                        â”‚
â”‚                                     â–¼                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  LAYER 4: Visual Fidelity (XML Hacks)                               â”‚   â”‚
â”‚   â”‚  â€¢ Opacity injection (<a:alpha> tags)                                â”‚   â”‚
â”‚   â”‚  â€¢ Z-order manipulation (physical XML element reordering)            â”‚   â”‚
â”‚   â”‚  â€¢ Features missing in python-pptx                                   â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                     â”‚                                        â”‚
â”‚                                     â–¼                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  LAYER 5: Accessibility Compliance                                   â”‚   â”‚
â”‚   â”‚  â€¢ WCAG 2.1 AA checking                                              â”‚   â”‚
â”‚   â”‚  â€¢ Color contrast calculation                                        â”‚   â”‚
â”‚   â”‚  â€¢ Alt text validation                                               â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 1.2 The Context Manager Pattern â€” Mandatory Usage

```python
from core.powerpoint_agent_core import PowerPointAgent, FileLockError

try:
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ATOMIC OPERATION PATTERN (The ONLY correct way to use the core)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    with PowerPointAgent(filepath) as agent:
        # Step 1: Acquire Lock & Load (with 10s timeout protection)
        agent.open(filepath, acquire_lock=True)
        
        # Step 2: Capture version BEFORE changes
        version_before = agent.get_presentation_version()
        
        # Step 3: Perform mutation (returns dict in v3.1+)
        result = agent.add_shape(...)
        
        # Step 4: Save changes (atomic write)
        agent.save()
        
        # Step 5: Capture version AFTER changes
        version_after = agent.get_presentation_version()
        
        # Step 6: Return with version tracking
        return {
            "status": "success",
            "presentation_version_before": version_before,
            "presentation_version_after": version_after,
            "result": result
        }
        
        # Step 7: Release Lock (automatic on context exit)
        
except FileLockError:
    # Handle contention gracefully (exit code 3)
    pass
```

---

# Part II: Version Hashing â€” The Observability Engine

## 2.1 What Gets Hashed

The `get_presentation_version()` method computes a SHA-256 hash (first 16 characters) from:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      VERSION HASH COMPUTATION                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   INPUT 1: Slide Count                                                       â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                       â”‚
â”‚   slide_count = 12                                                           â”‚
â”‚                                                                              â”‚
â”‚   INPUT 2: Layout Names (per slide)                                          â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚   layouts = ["Title Slide", "Title and Content", "Blank", ...]              â”‚
â”‚                                                                              â”‚
â”‚   INPUT 3: Shape Geometry (per shape)                                        â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                       â”‚
â”‚   geometry = "{left}:{top}:{width}:{height}"                                â”‚
â”‚   Example: "914400:914400:6858000:4572000" (in EMUs)                        â”‚
â”‚   âš ï¸ Detects: Moves, Resizes, Position changes                              â”‚
â”‚                                                                              â”‚
â”‚   INPUT 4: Text Content (SHA-256 of text runs)                              â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                              â”‚
â”‚   text_hash = SHA256("Hello World" + "Bullet 1" + ...)                      â”‚
â”‚   âš ï¸ Detects: Text edits, additions, deletions                              â”‚
â”‚                                                                              â”‚
â”‚   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â”‚
â”‚                                                                              â”‚
â”‚   OUTPUT: SHA-256 Hash (first 16 chars)                                      â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                     â”‚
â”‚   version = "a1b2c3d4e5f6g7h8"                                              â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 2.2 Why Geometry-Aware Versioning Matters

| Change Type | v2.0 Detection | v3.1.4 Detection |
|-------------|----------------|------------------|
| Add/remove text | âœ… Detected | âœ… Detected |
| Edit text content | âœ… Detected | âœ… Detected |
| Move shape by 1px | âŒ NOT detected | âœ… Detected |
| Resize shape | âŒ NOT detected | âœ… Detected |
| Change shape position | âŒ NOT detected | âœ… Detected |

**Impact**: In v3.1.4, ANY visual change to the presentation will change the version hash, enabling precise conflict detection.

## 2.3 Multi-Agent Workflow Integration

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Agent A     â”‚     â”‚   Agent B     â”‚     â”‚   Agent C     â”‚
â”‚   (Plan)      â”‚     â”‚   (Modify)    â”‚     â”‚   (Validate)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                     â”‚                     â”‚
        â”‚ capture version     â”‚                     â”‚
        â”‚ v = "a1b2c3d4"      â”‚                     â”‚
        â”‚                     â”‚                     â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º                     â”‚
        â”‚    pass expected    â”‚                     â”‚
        â”‚    version          â”‚ modify & save       â”‚
        â”‚                     â”‚ v = "e5f6g7h8"      â”‚
        â”‚                     â”‚                     â”‚
        â”‚                     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
        â”‚                     â”‚    pass new         â”‚
        â”‚                     â”‚    version          â”‚
        â”‚                     â”‚                     â”‚
        â”‚                     â”‚                     â”‚ validate
        â”‚                     â”‚                     â”‚ check version
        â”‚                     â”‚                     â”‚ matches expected
```

**Conflict Detection**:
```python
if expected_version != agent.get_presentation_version():
    raise VersionConflictError(
        "Presentation modified externally",
        expected=expected_version,
        actual=current_version
    )
```

---

# Part III: Performance Characteristics (Critical for Agent Design)

## 3.1 Operation Cost Matrix

| Operation | Complexity | 10-Slide Deck | 50-Slide Deck | Notes |
|-----------|------------|---------------|---------------|-------|
| `get_presentation_version()` | O(N) shapes | ~15ms | ~75ms | Called twice per mutation |
| `capability_probe(deep=True)` | O(M) layouts | ~120ms | ~600ms+ | Creates/destroys transient slides |
| `add_shape()` | O(1) | ~8ms | ~8ms | Constant time (XML injection) |
| `format_shape()` | O(1) | ~5ms | ~5ms | XML attribute updates |
| `replace_text(global)` | O(N) text runs | ~25ms | ~125ms | Regex across all text |
| `get_slide_info()` | O(K) shapes/slide | ~10ms | ~10ms | Per-slide operation |
| `save()` | I/O bound | ~50ms | ~200ms+ | Dominated by disk I/O |

## 3.2 Optimization Guidelines

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      PERFORMANCE OPTIMIZATION RULES                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  RULE 1: Size Limits                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                          â”‚
â”‚  â€¢ Avoid decks > 100 slides for interactive agent sessions                   â”‚
â”‚  â€¢ Avoid files > 50MB (images dominate file size)                           â”‚
â”‚  â€¢ Use image compression for inserted images                                 â”‚
â”‚                                                                              â”‚
â”‚  RULE 2: Probe Optimization                                                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
â”‚  â€¢ Use deep=False unless layout geometry is STRICTLY required               â”‚
â”‚  â€¢ Deep probes have 15s timeout for safety                                   â”‚
â”‚  â€¢ Limit layout analysis to 50 layouts maximum                               â”‚
â”‚                                                                              â”‚
â”‚  RULE 3: Batching (Within Context Manager)                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                   â”‚
â”‚  â€¢ Multiple mutations can share one save() in custom scripts                â”‚
â”‚  â€¢ NOT possible across CLI tool invocations (stateless design)              â”‚
â”‚                                                                              â”‚
â”‚  RULE 4: Version Check Awareness                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                              â”‚
â”‚  â€¢ get_presentation_version() is O(N) shapes - not free!                    â”‚
â”‚  â€¢ Called twice per mutation (before + after)                                â”‚
â”‚  â€¢ For very large decks, consider selective versioning                       â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 3.3 Performance Impact on Agent Workflows

```python
# Example: Estimated time for a 50-slide deck with 10 modifications

operations = [
    ("probe", 600),      # Deep probe: ~600ms
    ("add_shape", 8),    # Add shape: ~8ms
    ("version_check", 150),  # 2x version check: ~150ms
    ("save", 200),       # Save: ~200ms
    # ... repeat for each modification
]

# Total for 10 modifications:
# Probe: 600ms (once)
# Per-modification: 8 + 150 + 200 = 358ms
# Total: 600 + (10 Ã— 358) = ~4.2 seconds

# âš ï¸ For interactive sessions, keep modifications batched when possible
```

---

# Part IV: XML Magic â€” Features Beyond python-pptx

## 4.1 Opacity Injection

**Problem**: `python-pptx` does not support shape transparency/opacity.

**Solution**: Direct XML injection using `lxml`:

```xml
<!-- OOXML Structure for 50% Opacity -->
<a:solidFill>
  <a:srgbClr val="FF0000">
    <a:alpha val="50000"/>  <!-- Office uses 0-100,000 scale -->
  </a:srgbClr>
</a:solidFill>
```

**Core Implementation Pattern**:
```python
def _set_fill_opacity(self, shape, opacity: float):
    """
    Inject opacity into shape's fill.
    
    Args:
        shape: python-pptx shape object
        opacity: 0.0 (invisible) to 1.0 (opaque)
    """
    from lxml import etree
    from pptx.oxml.ns import qn
    
    # Convert 0.0-1.0 to Office's 0-100,000 scale
    alpha_val = int(opacity * 100000)
    
    # Find or create solidFill element
    spPr = shape._sp.spPr
    solidFill = spPr.find(qn('a:solidFill'))
    if solidFill is None:
        solidFill = etree.SubElement(spPr, qn('a:solidFill'))
    
    # Find or create color element
    srgbClr = solidFill.find(qn('a:srgbClr'))
    if srgbClr is None:
        srgbClr = etree.SubElement(solidFill, qn('a:srgbClr'))
        srgbClr.set('val', 'FFFFFF')  # Default white
    
    # Remove existing alpha, add new one
    for alpha in srgbClr.findall(qn('a:alpha')):
        srgbClr.remove(alpha)
    
    alpha_elem = etree.SubElement(srgbClr, qn('a:alpha'))
    alpha_elem.set('val', str(alpha_val))
```

**Scale Conversion**:
| User Input | Office XML Value | Visual Effect |
|------------|------------------|---------------|
| `0.0` | `0` | Invisible |
| `0.15` | `15000` | Subtle overlay |
| `0.5` | `50000` | Half transparent |
| `1.0` | `100000` | Fully opaque |

## 4.2 Z-Order Manipulation

**Problem**: `python-pptx` does not support changing shape layering.

**Solution**: Physically reorder XML elements in the shape tree:

```xml
<!-- OOXML Shape Tree Structure -->
<p:spTree>
  <p:nvGrpSpPr>...</p:nvGrpSpPr>  <!-- Index 0: Group properties -->
  <p:grpSpPr>...</p:grpSpPr>      <!-- Index 1: Group shape props -->
  <p:sp><!-- Shape A --></p:sp>   <!-- Index 2: First shape -->
  <p:sp><!-- Shape B --></p:sp>   <!-- Index 3: Second shape -->
  <p:sp><!-- Shape C --></p:sp>   <!-- Index 4: Third shape -->
</p:spTree>
```

**Z-Order Actions**:
| Action | Implementation | Result |
|--------|----------------|--------|
| `bring_to_front` | Move `<p:sp>` to end of list | Shape renders on top |
| `send_to_back` | Move `<p:sp>` to index 2 | Shape renders behind all |
| `bring_forward` | Swap with next sibling | One layer up |
| `send_backward` | Swap with previous sibling | One layer down |

**âš ï¸ CRITICAL SIDE EFFECT**:
```python
# Before set_z_order:
# shapes = [Title(0), Rectangle(1), Circle(2), Arrow(3)]

agent.set_z_order(slide_index=0, shape_index=3, action="send_to_back")

# After set_z_order:
# shapes = [Title(0), Arrow(1), Rectangle(2), Circle(3)]
#                     â†‘ Was index 3, now index 1!

# âš ï¸ ALL INDICES HAVE SHIFTED - MUST REFRESH
slide_info = agent.get_slide_info(slide_index=0)
```

## 4.3 Debugging OOXML Issues

When visual features don't work as expected:

```python
from lxml import etree

# Step 1: Export the shape's XML
print(etree.tostring(shape.element, pretty_print=True).decode())

# Step 2: Verify namespaces
# Ensure 'a:' corresponds to:
# http://schemas.openxmlformats.org/drawingml/2006/main

# Step 3: Check for missing parents
# Opacity requires <a:solidFill> to exist
# If shape has no fill, injection fails
```

---

# Part V: API Reference (Comprehensive)

## 5.1 File Operations

| Method | Signature | Safety Features |
|--------|-----------|-----------------|
| `open()` | `open(filepath, acquire_lock=True)` | Atomic locking via `O_CREAT\|O_EXCL`, 10s timeout |
| `save()` | `save(filepath=None)` | Creates parent dirs, overwrites if None |
| `clone_presentation()` | `clone_presentation(output_path)` | Returns NEW agent instance |
| `close()` | `close()` | Releases lock, called automatically by context manager |

### File Locking Implementation Detail

```python
# Cross-platform atomic locking (simplified)
import os, errno

def acquire_lock(filepath, timeout=10):
    lock_path = filepath.with_suffix('.pptx.lock')
    start = time.time()
    
    while time.time() - start < timeout:
        try:
            # O_CREAT|O_EXCL = Create exclusively (fails if exists)
            fd = os.open(lock_path, os.O_CREAT | os.O_EXCL | os.O_WRONLY)
            os.close(fd)
            return True  # Lock acquired
        except OSError as e:
            if e.errno == errno.EEXIST:
                time.sleep(0.1)  # Lock held, retry
            else:
                raise
    
    raise FileLockError(f"Lock timeout after {timeout}s")
```

## 5.2 Slide Operations

| Method | Returns (v3.1+) | Destructive? | Token Required? |
|--------|-----------------|--------------|-----------------|
| `add_slide(layout_name, index=None)` | Dict with `slide_index`, `layout_name`, `total_slides`, versions | No | No |
| `delete_slide(index, approval_token)` | None | **Yes** | **Yes** (`delete:slide`) |
| `duplicate_slide(index)` | Dict with `new_slide_index` | No | No |
| `reorder_slides(from_index, to_index)` | None | No | No |

### v3.0 â†’ v3.1 Migration

```python
# v3.0 pattern (deprecated but still works)
idx = agent.add_slide("Blank")  # Returns int

# v3.1 pattern (recommended)
result = agent.add_slide("Blank")  # Returns dict
idx = result["slide_index"]
version = result["presentation_version_after"]
```

## 5.3 Shape Operations

| Method | Key Arguments | Returns | Index Impact |
|--------|---------------|---------|--------------|
| `add_shape()` | `shape_type`, `position`, `size`, `fill_opacity`, `line_opacity` | Dict with `shape_index`, `styling` | Adds at end |
| `format_shape()` | `fill_color`, `fill_opacity`, `line_color` | Dict with `changes_applied` | None |
| `remove_shape()` | `slide_index`, `shape_index`, `approval_token` | None | **Shifts all subsequent** |
| `set_z_order()` | `action`: `bring_to_front`/`send_to_back`/etc | Dict with `z_order_change` | **Reorders all** |

### Deprecation: `transparency` Parameter

```python
# âš ï¸ DEPRECATED (logs warning, auto-converts)
agent.format_shape(slide_index=0, shape_index=1, transparency=0.85)
# Internally converts: fill_opacity = 1.0 - 0.85 = 0.15

# âœ… PREFERRED (v3.1+)
agent.format_shape(slide_index=0, shape_index=1, fill_opacity=0.15)
```

## 5.4 Text & Content Operations

| Method | Purpose | Modes/Options |
|--------|---------|---------------|
| `add_text_box()` | Create text container | Auto-fit, font styling, alignment |
| `add_bullet_list()` | Create bullet list | `bullet`, `numbered`, `none` |
| `set_title()` | Set title/subtitle | Uses layout placeholders |
| `replace_text()` | Find/replace | Global or scoped (`slide`/`shape`), `match_case` |
| `add_notes()` | Speaker notes | `append`, `prepend`, `overwrite` |
| `set_footer()` | Configure footer | Iterates all slides for placeholders (types 5, 6, 7) |

### Footer Mechanism Detail

```python
# Footer uses placeholder types:
# Type 5: Date/Time placeholder
# Type 6: Slide Number placeholder  
# Type 7: Footer text placeholder

# Behavior:
# 1. Iterates through ALL slides
# 2. Looks for placeholders by type
# 3. Sets text/visibility if found
# 4. Returns slides_processed count
# 5. Does NOT create text boxes (tool layer handles fallback)
```

## 5.5 Chart Operations

| Method | Purpose | Data Format |
|--------|---------|-------------|
| `add_chart()` | Create chart | `{"categories": [...], "series": [{"name": "...", "values": [...]}]}` |
| `update_chart_data()` | Update data | Same format as `add_chart()` |
| `format_chart()` | Style chart | `title`, `legend_position` |

### Chart Update Strategy (3-Tier)

```python
def update_chart_data(self, slide_index, chart_index, data):
    """
    Update chart with 3-tier fallback strategy.
    """
    try:
        # Tier 1: Best - Use replace_data() (preserves all formatting)
        chart.replace_data(chart_data)
        
    except AttributeError:
        # Tier 2: Older python-pptx versions lack replace_data
        try:
            # Try direct workbook manipulation
            self._update_chart_workbook(chart, data)
            
        except Exception:
            # Tier 3: Fallback - Recreate chart in place
            # Preserves: position, size, title
            # Resets: custom styling, some formatting
            self._recreate_chart_in_place(slide_index, chart_index, data)
```

## 5.6 Image Operations

| Method | Key Features |
|--------|--------------|
| `insert_image()` | Auto-aspect ratio, optional compression (Pillow), alt text |
| `replace_image()` | Match by name/partial, preserve position |
| `crop_image()` | Percentage-based crop box |
| `set_image_properties()` | Alt text for accessibility |

---

# Part VI: Advanced Patterns (Production-Grade)

## 6.1 Transient Slide Pattern

**Purpose**: Analyze layout geometry accurately without corrupting the file.

```python
from contextlib import contextmanager

@contextmanager
def transient_slide(prs, layout):
    """
    Create temporary slide for analysis, guaranteed cleanup.
    
    CRITICAL: Never call save() while transient slide exists!
    """
    slide = None
    added_index = -1
    
    try:
        # Create temporary slide
        slide = prs.slides.add_slide(layout)
        added_index = len(prs.slides) - 1
        
        # Yield for analysis
        yield slide
        
    finally:
        # ALWAYS cleanup (even on exception)
        if added_index != -1 and added_index < len(prs.slides):
            try:
                # Remove slide from relationships
                rId = prs.slides._sldIdLst[added_index].rId
                prs.part.drop_rel(rId)
                
                # Remove from slide ID list
                del prs.slides._sldIdLst[added_index]
                
            except Exception:
                # Suppress cleanup errors
                # File not saved, so transient slide vanishes anyway
                pass
```

**Usage**:
```python
for layout in prs.slide_layouts:
    with transient_slide(prs, layout) as slide:
        # Get REAL positions (not template theoretical positions)
        positions = extract_placeholder_positions(slide)
        # Slide automatically removed on exit
```

## 6.2 Production Probe Resilience (3-Layer Pattern)

```python
import time
from pathlib import Path

def probe_with_resilience(
    filepath: Path,
    deep: bool = False,
    timeout_seconds: int = 15,
    max_layouts: int = 50
) -> dict:
    """
    Production-grade probe with timeout + transient + degradation.
    """
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # LAYER 1: Timeout Protection
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    start_time = time.perf_counter()
    warnings = []
    info = []
    
    prs = Presentation(str(filepath))
    all_layouts = list(prs.slide_layouts)
    
    # Cap layout count
    if len(all_layouts) > max_layouts:
        info.append(f"Limited to first {max_layouts} of {len(all_layouts)} layouts")
        layouts_to_analyze = all_layouts[:max_layouts]
    else:
        layouts_to_analyze = all_layouts
    
    results = []
    
    for idx, layout in enumerate(layouts_to_analyze):
        # Check timeout at EACH iteration
        elapsed = time.perf_counter() - start_time
        if elapsed > timeout_seconds:
            warnings.append(
                f"Timeout at layout {idx} ({elapsed:.2f}s > {timeout_seconds}s)"
            )
            break  # Return partial results
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # LAYER 2: Transient Slide Analysis (if deep mode)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if deep:
            with transient_slide(prs, layout) as slide:
                layout_data = analyze_layout_deep(slide)
        else:
            layout_data = analyze_layout_fast(layout)
        
        results.append(layout_data)
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # LAYER 3: Graceful Degradation
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    analysis_complete = len(results) == len(layouts_to_analyze)
    
    return {
        "status": "success",
        "layouts_analyzed": len(results),
        "layouts_total": len(all_layouts),
        "analysis_complete": analysis_complete,
        "partial_results": not analysis_complete,
        "deep_analysis": deep,
        "layouts": results,
        "warnings": warnings,
        "info": info,
        "duration_ms": int((time.perf_counter() - start_time) * 1000)
    }
```

---

# Part VII: Error Handling Matrix (Finalized)

## 7.1 Exit Code Reference

| Code | Category | Exception Type | Retryable | Example |
|------|----------|---------------|-----------|---------|
| `0` | Success | N/A | N/A | Operation completed |
| `1` | Usage | `ValueError`, `SlideNotFoundError`, `ShapeNotFoundError` | No | Invalid argument |
| `2` | Validation | `ValidationError` | No | Schema mismatch |
| `3` | Transient | `FileLockError`, `TimeoutError` | **Yes** | File locked |
| `4` | Permission | `ApprovalTokenError` | No | Token missing/invalid |
| `5` | Internal | `PowerPointAgentError` | Maybe | Unexpected crash |

## 7.2 Standard Error Response Format

```json
{
  "status": "error",
  "error": "Human-readable message",
  "error_type": "ExceptionClassName",
  "details": {
    "specific": "context",
    "data": "here"
  },
  "suggestion": "Actionable fix recommendation",
  "retryable": false
}
```

## 7.3 Concrete Examples

**Shape Index Error (Exit 1)**:
```json
{
  "status": "error",
  "error": "Shape index 10 out of range (0-8)",
  "error_type": "ShapeNotFoundError",
  "details": {
    "requested": 10,
    "available": 9
  },
  "suggestion": "Refresh shape indices using ppt_get_slide_info.py before targeting shapes"
}
```

**File Lock Error (Exit 3 â€” Retryable)**:
```json
{
  "status": "error",
  "error": "File lock timeout after 10s",
  "error_type": "FileLockError",
  "details": {
    "file": "/work/presentation.pptx",
    "timeout_seconds": 10
  },
  "suggestion": "Check for .pptx.lock files or stale processes. Retry with exponential backoff.",
  "retryable": true
}
```

**Approval Token Error (Exit 4)**:
```json
{
  "status": "error",
  "error": "Approval token required for slide deletion",
  "error_type": "ApprovalTokenError",
  "details": {
    "operation": "delete_slide",
    "required_scope": "delete:slide"
  },
  "suggestion": "Generate approval token with scope 'delete:slide' and retry"
}
```

---

# Part VIII: Troubleshooting Playbook

## 8.1 Common Scenarios & Solutions

| Scenario | Symptom | Root Cause | Solution |
|----------|---------|------------|----------|
| **Stale Indices** | `ShapeNotFoundError` after operations | Index shifted after `remove_shape`/`set_z_order` | Call `get_slide_info()` immediately after structural ops |
| **File Lock Timeout** | `FileLockError` after 10s | Crashed process left `.pptx.lock` | Delete lock file, implement retry with backoff |
| **Chart Format Lost** | Styling reset after `update_chart_data` | Fallback recreation triggered | Use `format_chart()` after update to restore styling |
| **Opacity Not Applied** | Shape fully opaque despite setting | No `<a:solidFill>` parent exists | Ensure shape has fill color before setting opacity |
| **Layout Not Found** | `LayoutNotFoundError` | Layout name doesn't match template | Use `capability_probe` to discover exact names |
| **Version Mismatch** | Unexpected `presentation_version` | External modification between operations | Re-probe, update manifest, verify no concurrent edits |

## 8.2 OOXML Debugging Workflow

```python
# Step 1: Export shape XML for inspection
from lxml import etree

def debug_shape(shape):
    xml_str = etree.tostring(shape.element, pretty_print=True).decode()
    print(xml_str)
    
    # Check for expected elements
    spPr = shape._sp.spPr
    
    # Verify fill exists
    solidFill = spPr.find(qn('a:solidFill'))
    print(f"Has solidFill: {solidFill is not None}")
    
    # Verify alpha (opacity) exists
    if solidFill is not None:
        alpha = solidFill.find('.//a:alpha', namespaces={'a': NS_A})
        print(f"Has alpha: {alpha is not None}")
        if alpha is not None:
            print(f"Alpha value: {alpha.get('val')}")
```

---

# Part IX: Workflow Phase Integration

## 9.1 Core Methods by Phase

| Phase | Core Methods | Requirements |
|-------|--------------|--------------|
| **DISCOVER** | `get_presentation_info()`, `get_slide_info()`, `get_capabilities()` | 15s timeout, graceful degradation |
| **PLAN** | `get_presentation_version()` | Version capture for manifest |
| **CREATE** | All mutation methods | Version tracking, approval tokens, index refresh |
| **VALIDATE** | `validate_presentation()`, `check_accessibility()` | Severity categorization |
| **DELIVER** | `export_to_pdf()`, `extract_notes()` | Complete audit trails |

## 9.2 Phase-Specific Implementation Patterns

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DISCOVER Phase Implementation
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def discover_phase(filepath: Path):
    with PowerPointAgent(filepath) as agent:
        agent.open(filepath)
        
        # Capture initial version
        version = agent.get_presentation_version()
        
        # Get comprehensive info
        info = agent.get_presentation_info()
        
        # Deep probe with resilience
        probe = probe_with_resilience(filepath, deep=True, timeout_seconds=15)
        
        return {
            "presentation_version": version,
            "info": info,
            "probe": probe
        }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CREATE Phase Implementation
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def create_phase(filepath: Path, operations: list):
    with PowerPointAgent(filepath) as agent:
        agent.open(filepath)
        
        results = []
        
        for op in operations:
            # Capture version BEFORE
            version_before = agent.get_presentation_version()
            
            # Execute operation
            if op["type"] == "add_shape":
                result = agent.add_shape(**op["args"])
                
                # Refresh indices if structural
                slide_info = agent.get_slide_info(op["args"]["slide_index"])
                
            elif op["type"] == "set_z_order":
                result = agent.set_z_order(**op["args"])
                
                # CRITICAL: Refresh after z-order
                slide_info = agent.get_slide_info(op["args"]["slide_index"])
            
            # Save after each operation (atomic pattern)
            agent.save()
            
            # Capture version AFTER
            version_after = agent.get_presentation_version()
            
            results.append({
                "operation": op,
                "result": result,
                "version_before": version_before,
                "version_after": version_after
            })
        
        return results
```

---

# Part X: Integration Checklist

## 10.1 Core Usage Verification

Before using the core library, verify:

- [ ] **Context Manager**: Using `with PowerPointAgent() as agent:` pattern
- [ ] **Lock Acquisition**: `agent.open(filepath, acquire_lock=True)`
- [ ] **Version Tracking**: Capturing before/after versions for all mutations
- [ ] **Index Refresh**: Calling `get_slide_info()` after structural operations
- [ ] **Approval Tokens**: Providing valid tokens for destructive operations
- [ ] **Error Handling**: Catching specific exceptions with correct exit codes
- [ ] **Logging Config**: Sending logs to stderr, not stdout

## 10.2 Performance Considerations

- [ ] **Deck Size**: Keeping under 100 slides / 50MB for interactive sessions
- [ ] **Probe Depth**: Using `deep=False` unless geometry required
- [ ] **Version Checks**: Understanding O(N) cost for large presentations
- [ ] **Batching**: Grouping mutations within single context manager when possible

## 10.3 XML Magic Awareness

- [ ] **Opacity**: Understanding 0-100,000 Office scale (core converts automatically)
- [ ] **Z-Order**: Knowing that index changes affect ALL shapes on slide
- [ ] **Fill Requirement**: Shapes must have fill color before opacity can be set
- [ ] **Debugging**: Knowing how to export and inspect OOXML when issues arise

---

# Conclusion

I now have a **complete, integrated understanding** of the PowerPoint Agent Tools codebase:

| Layer | Understanding Level |
|-------|---------------------|
| **Project Mission** | âœ… Deep â€” AI-driven presentation engineering with safety |
| **Architecture** | âœ… Deep â€” Hub-and-spoke, stateless tools, atomic operations |
| **Workflow** | âœ… Deep â€” 5-phase (Discoverâ†’Planâ†’Createâ†’Validateâ†’Deliver) |
| **Governance** | âœ… Deep â€” Clone-before-edit, approval tokens, version tracking |
| **Core Library** | âœ… Deep â€” API methods, XML magic, performance characteristics |
| **Tool Development** | âœ… Deep â€” Templates, patterns, error handling, testing |

I am **fully prepared** to:

1. **Create new CLI tools** following established patterns
2. **Debug existing tools** with knowledge of internal mechanisms
3. **Implement core enhancements** respecting backward compatibility
4. **Optimize performance** based on operation cost awareness
5. **Troubleshoot issues** using OOXML debugging techniques

**What would you like to work on?** ğŸ› ï¸
