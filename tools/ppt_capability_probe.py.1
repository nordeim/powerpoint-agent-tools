#!/usr/bin/env python3
"""
PowerPoint Capability Probe Tool v3.1.0
Detect and report presentation template capabilities, layouts, and theme properties.

This tool provides comprehensive introspection of PowerPoint presentations to detect:
- Available layouts and their placeholders (with accurate runtime positions)
- Slide dimensions and aspect ratios
- Theme colors and fonts (using proper font scheme API)
- Template capabilities (footer support, slide numbers, dates)
- Multiple master slide support

Critical for AI agents and automation workflows to understand template capabilities
before generating content.

Usage:
    # Basic probe (essential info)
    uv run tools/ppt_capability_probe.py --file template.pptx --json
    
    # Deep probe (accurate positions via transient instantiation)
    uv run tools/ppt_capability_probe.py --file template.pptx --deep --json
    
    # Human-friendly summary
    uv run tools/ppt_capability_probe.py --file template.pptx --summary

Exit Codes:
    0: Success
    1: Error occurred

Design Principles:
    - Read-only operation (atomic, no file mutation)
    - JSON-first output with consistent contract
    - Accurate data via transient slide instantiation
    - Graceful degradation for missing features
    - Performance-optimized with timeout protection

Author: PowerPoint Agent Team
License: MIT
Version: 3.1.0
"""

import sys
import os

# --- HYGIENE BLOCK START ---
# CRITICAL: Redirect stderr to /dev/null immediately to prevent library noise.
# This guarantees that `jq` or other parsers only see your JSON on stdout.
sys.stderr = open(os.devnull, 'w')
# --- HYGIENE BLOCK END ---

import json
import argparse
import hashlib
import uuid
import time
import logging
import importlib.metadata
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
from fractions import Fraction

# Configure logging to null handler
logging.basicConfig(level=logging.CRITICAL)

# Add parent directory to path for core import
sys.path.insert(0, str(Path(__file__).parent.parent))

# ============================================================================
# CONSTANTS
# ============================================================================

__version__ = "3.1.0"
SCHEMA_VERSION = "capability_probe.v3.1.0"
DEFAULT_TIMEOUT_SECONDS = 15
DEFAULT_MAX_LAYOUTS = 50

# ============================================================================
# SAFE IMPORTS
# ============================================================================

try:
    from pptx import Presentation
    from pptx.enum.shapes import PP_PLACEHOLDER
    PPTX_AVAILABLE = True
except ImportError:
    PPTX_AVAILABLE = False
    PP_PLACEHOLDER = None

try:
    from core.powerpoint_agent_core import PowerPointAgentError
except ImportError:
    class PowerPointAgentError(Exception):
        """Fallback exception class."""
        pass

try:
    from core.strict_validator import validate_against_schema
    STRICT_VALIDATOR_AVAILABLE = True
except ImportError:
    STRICT_VALIDATOR_AVAILABLE = False
    def validate_against_schema(data, schema_path):
        pass

# ============================================================================
# LIBRARY VERSION DETECTION
# ============================================================================

def get_library_versions() -> Dict[str, str]:
    """
    Detect versions of key libraries.
    
    Returns:
        Dict mapping library name to version string
    """
    versions = {}
    
    try:
        versions["python-pptx"] = importlib.metadata.version("python-pptx")
    except importlib.metadata.PackageNotFoundError:
        versions["python-pptx"] = "not_installed"
    except Exception:
        versions["python-pptx"] = "unknown"
    
    try:
        versions["Pillow"] = importlib.metadata.version("Pillow")
    except importlib.metadata.PackageNotFoundError:
        versions["Pillow"] = "not_installed"
    except Exception:
        versions["Pillow"] = "unknown"
    
    try:
        versions["lxml"] = importlib.metadata.version("lxml")
    except importlib.metadata.PackageNotFoundError:
        versions["lxml"] = "not_installed"
    except Exception:
        versions["lxml"] = "unknown"
    
    return versions

# ============================================================================
# PLACEHOLDER TYPE MAPPING
# ============================================================================

def build_placeholder_type_map() -> Dict[int, str]:
    """
    Build mapping from PP_PLACEHOLDER enum values to human-readable names.
    
    Uses actual python-pptx enum values, not guessed numbers.
    
    Returns:
        Dict mapping type code to name
    """
    type_map = {}
    
    if PP_PLACEHOLDER is None:
        return type_map
    
    for name in dir(PP_PLACEHOLDER):
        if name.isupper() and not name.startswith('_'):
            try:
                member = getattr(PP_PLACEHOLDER, name)
                if isinstance(member, int):
                    code = member
                elif hasattr(member, 'value'):
                    code = member.value
                else:
                    continue
                if code is not None:
                    type_map[int(code)] = name
            except (AttributeError, TypeError, ValueError):
                continue
    
    return type_map


PLACEHOLDER_TYPE_MAP = build_placeholder_type_map()


def get_placeholder_type_name(ph_type_code: int) -> str:
    """
    Get human-readable name for placeholder type code.
    
    Args:
        ph_type_code: Numeric type code from placeholder
        
    Returns:
        Type name or UNKNOWN_X if not recognized
    """
    return PLACEHOLDER_TYPE_MAP.get(ph_type_code, f"UNKNOWN_{ph_type_code}")

# ============================================================================
# FILE UTILITIES
# ============================================================================

def calculate_file_checksum(filepath: Path) -> str:
    """
    Calculate MD5 checksum of file to verify no mutation.
    
    Args:
        filepath: Path to file
        
    Returns:
        Hex digest of file contents
    """
    md5 = hashlib.md5()
    with open(filepath, 'rb') as f:
        for chunk in iter(lambda: f.read(8192), b''):
            md5.update(chunk)
    return md5.hexdigest()

# ============================================================================
# COLOR UTILITIES
# ============================================================================

def rgb_to_hex(rgb_color) -> str:
    """
    Convert RGBColor to hex string.
    
    Args:
        rgb_color: RGBColor object from python-pptx
        
    Returns:
        Hex color string like "#0070C0"
    """
    try:
        return f"#{rgb_color.r:02X}{rgb_color.g:02X}{rgb_color.b:02X}"
    except (AttributeError, TypeError):
        return "#000000"

# ============================================================================
# DIMENSION DETECTION
# ============================================================================

def detect_slide_dimensions(prs) -> Dict[str, Any]:
    """
    Detect slide dimensions and calculate aspect ratio.
    
    Args:
        prs: Presentation object
        
    Returns:
        Dict with width, height, aspect ratio, DPI estimate
    """
    width_inches = prs.slide_width.inches
    height_inches = prs.slide_height.inches
    
    width_emu = int(prs.slide_width)
    height_emu = int(prs.slide_height)
    
    dpi_estimate = 96
    width_pixels = int(width_inches * dpi_estimate)
    height_pixels = int(height_inches * dpi_estimate)
    
    ratio = width_inches / height_inches if height_inches > 0 else 0
    
    if abs(ratio - 16/9) < 0.01:
        aspect_ratio = "16:9"
    elif abs(ratio - 4/3) < 0.01:
        aspect_ratio = "4:3"
    elif width_pixels > 0 and height_pixels > 0:
        frac = Fraction(width_pixels, height_pixels).limit_denominator(20)
        aspect_ratio = f"{frac.numerator}:{frac.denominator}"
    else:
        aspect_ratio = "unknown"
    
    return {
        "width_inches": round(width_inches, 2),
        "height_inches": round(height_inches, 2),
        "width_emu": width_emu,
        "height_emu": height_emu,
        "width_pixels": width_pixels,
        "height_pixels": height_pixels,
        "aspect_ratio": aspect_ratio,
        "aspect_ratio_float": round(ratio, 4),
        "dpi_estimate": dpi_estimate
    }

# ============================================================================
# PLACEHOLDER ANALYSIS
# ============================================================================

def analyze_placeholder(
    shape, 
    slide_width: float, 
    slide_height: float, 
    instantiated: bool = False
) -> Dict[str, Any]:
    """
    Analyze a single placeholder and return comprehensive info.
    
    Args:
        shape: Placeholder shape to analyze
        slide_width: Slide width in inches
        slide_height: Slide height in inches
        instantiated: Whether this is from an instantiated slide (accurate) or template
        
    Returns:
        Dict with type, position, size information
    """
    ph_format = shape.placeholder_format
    ph_type = ph_format.type if hasattr(ph_format.type, '__int__') else int(ph_format.type) if ph_format.type else 0
    ph_type_name = get_placeholder_type_name(ph_type)
    
    try:
        left_emu = int(shape.left) if hasattr(shape, 'left') and shape.left is not None else 0
        top_emu = int(shape.top) if hasattr(shape, 'top') and shape.top is not None else 0
        width_emu = int(shape.width) if hasattr(shape, 'width') and shape.width is not None else 0
        height_emu = int(shape.height) if hasattr(shape, 'height') and shape.height is not None else 0
        
        # Convert EMU to inches (914400 EMU per inch)
        left_inches = left_emu / 914400
        top_inches = top_emu / 914400
        width_inches = width_emu / 914400
        height_inches = height_emu / 914400
        
        # Calculate percentages
        left_percent = (left_inches / slide_width * 100) if slide_width > 0 else 0
        top_percent = (top_inches / slide_height * 100) if slide_height > 0 else 0
        width_percent = (width_inches / slide_width * 100) if slide_width > 0 else 0
        height_percent = (height_inches / slide_height * 100) if slide_height > 0 else 0
        
        return {
            "type": ph_type_name,
            "type_code": ph_type,
            "idx": ph_format.idx,
            "name": shape.name,
            "position_inches": {
                "left": round(left_inches, 2),
                "top": round(top_inches, 2)
            },
            "position_percent": {
                "left": f"{left_percent:.1f}%",
                "top": f"{top_percent:.1f}%"
            },
            "position_emu": {
                "left": left_emu,
                "top": top_emu
            },
            "size_inches": {
                "width": round(width_inches, 2),
                "height": round(height_inches, 2)
            },
            "size_percent": {
                "width": f"{width_percent:.1f}%",
                "height": f"{height_percent:.1f}%"
            },
            "size_emu": {
                "width": width_emu,
                "height": height_emu
            },
            "position_source": "instantiated" if instantiated else "template"
        }
    except Exception as e:
        return {
            "type": ph_type_name,
            "type_code": ph_type,
            "idx": ph_format.idx if hasattr(ph_format, 'idx') else None,
            "error": str(e),
            "position_source": "error"
        }

# ============================================================================
# TRANSIENT SLIDE PATTERN
# ============================================================================

def _add_transient_slide(prs, layout):
    """
    Helper to safely add and remove a transient slide for deep analysis.
    
    Uses generator pattern to guarantee cleanup via finally block.
    This is the production probe resilience pattern - Layer 2.
    
    Args:
        prs: Presentation object
        layout: Layout to instantiate
        
    Yields:
        Temporary slide object for analysis
        
    Note:
        Never call save() while a transient slide exists.
        The slide is automatically cleaned up when the generator exits.
    """
    slide = None
    added_index = -1
    try:
        slide = prs.slides.add_slide(layout)
        added_index = len(prs.slides) - 1
        yield slide
    finally:
        if added_index != -1 and added_index < len(prs.slides):
            try:
                rId = prs.slides._sldIdLst[added_index].rId
                prs.part.drop_rel(rId)
                del prs.slides._sldIdLst[added_index]
            except Exception:
                # Suppress cleanup errors to avoid masking analysis failures
                # File is not saved, so transient slide disappears anyway
                pass

# ============================================================================
# LAYOUT DETECTION
# ============================================================================

def detect_layouts_with_instantiation(
    prs, 
    slide_width: float, 
    slide_height: float, 
    deep: bool, 
    warnings: List[str], 
    timeout_start: Optional[float] = None, 
    timeout_seconds: Optional[int] = None, 
    max_layouts: Optional[int] = None
) -> List[Dict[str, Any]]:
    """
    Detect all layouts, optionally instantiating them for accurate positions.
    
    In deep mode, creates transient slides in-memory to get runtime positions,
    then discards them without saving (maintains atomic read guarantee).
    
    This implements the probe resilience pattern - Layer 1 (timeout) and Layer 2 (transient).
    
    Args:
        prs: Presentation object
        slide_width: Slide width in inches
        slide_height: Slide height in inches
        deep: If True, instantiate layouts for accurate positions
        warnings: List to append warnings to
        timeout_start: Start time for timeout check
        timeout_seconds: Max seconds allowed
        max_layouts: Maximum number of layouts to analyze
        
    Returns:
        List of layout information dicts
    """
    layouts = []
    
    # Build mapping: layout partname -> master index for stability
    master_map = {}
    try:
        for m_idx, master in enumerate(prs.slide_masters):
            for layout in master.slide_layouts:
                try:
                    key = layout.part.partname
                except AttributeError:
                    key = f"master_{m_idx}_layout_{id(layout)}"
                master_map[key] = m_idx
    except Exception:
        pass

    # Get layouts to process with optional limit
    all_layouts = list(prs.slide_layouts)
    layouts_to_process = all_layouts
    
    if max_layouts and len(all_layouts) > max_layouts:
        layouts_to_process = all_layouts[:max_layouts]
    
    for idx, layout in enumerate(layouts_to_process):
        # Layer 1: Timeout check at each iteration
        if timeout_start and timeout_seconds:
            elapsed = time.perf_counter() - timeout_start
            if elapsed > timeout_seconds:
                warnings.append(
                    f"Probe timeout at layout {idx} ({elapsed:.2f}s > {timeout_seconds}s) - "
                    "returning partial results"
                )
                break

        # Determine original index in full list
        try:
            original_idx = all_layouts.index(layout)
        except ValueError:
            original_idx = idx

        # Get stable key for master mapping
        try:
            layout_key = layout.part.partname
        except AttributeError:
            layout_key = f"layout_{id(layout)}"
            
        layout_info = {
            "index": idx,
            "original_index": original_idx, 
            "name": layout.name,
            "placeholder_count": len(layout.placeholders),
            "master_index": master_map.get(layout_key)
        }
        
        if deep:
            # Layer 2: Transient slide instantiation for accurate positions
            try:
                instantiation_success = False
                for temp_slide in _add_transient_slide(prs, layout):
                    instantiation_success = True
                    
                    # Map instantiated placeholders by idx for lookup
                    instantiated_map = {}
                    for shape in temp_slide.placeholders:
                        try:
                            instantiated_map[shape.placeholder_format.idx] = shape
                        except (AttributeError, TypeError):
                            pass
                    
                    placeholders = []
                    # Iterate layout placeholders (source of truth for existence)
                    for layout_ph in layout.placeholders:
                        try:
                            ph_idx = layout_ph.placeholder_format.idx
                            if ph_idx in instantiated_map:
                                # Use instantiated shape for accurate position
                                ph_info = analyze_placeholder(
                                    instantiated_map[ph_idx], 
                                    slide_width, 
                                    slide_height, 
                                    instantiated=True
                                )
                            else:
                                # Fallback to layout shape
                                ph_info = analyze_placeholder(
                                    layout_ph, 
                                    slide_width, 
                                    slide_height, 
                                    instantiated=False
                                )
                            placeholders.append(ph_info)
                        except Exception:
                            pass
                    
                    layout_info["placeholders"] = placeholders
                    layout_info["instantiation_complete"] = len(placeholders) == len(layout.placeholders)
                    layout_info["placeholder_expected"] = len(layout.placeholders)
                    layout_info["placeholder_instantiated"] = len(placeholders)

                if not instantiation_success:
                    raise RuntimeError("Transient slide creation failed")
                
            except Exception as e:
                warnings.append(f"Could not instantiate layout '{layout.name}': {str(e)}")
                
                # Fallback to template positions
                placeholders = []
                for shape in layout.placeholders:
                    try:
                        ph_info = analyze_placeholder(shape, slide_width, slide_height, instantiated=False)
                        placeholders.append(ph_info)
                    except Exception:
                        pass
                
                layout_info["placeholders"] = placeholders
                layout_info["instantiation_complete"] = False
                layout_info["placeholder_expected"] = len(layout.placeholders)
                layout_info["placeholder_instantiated"] = len(placeholders)
                layout_info["_warning"] = "Using template positions (instantiation failed)"
        
        # Build placeholder type summary (always, for quick reference)
        placeholder_map = {}
        placeholder_types = []
        for shape in layout.placeholders:
            try:
                ph_type = shape.placeholder_format.type
                ph_type_code = ph_type if isinstance(ph_type, int) else int(ph_type) if ph_type else 0
                ph_type_name = get_placeholder_type_name(ph_type_code)
                
                placeholder_map[ph_type_name] = placeholder_map.get(ph_type_name, 0) + 1
                
                if ph_type_name not in placeholder_types:
                    placeholder_types.append(ph_type_name)
            except Exception:
                pass
        
        layout_info["placeholder_types"] = placeholder_types
        layout_info["placeholder_map"] = placeholder_map
        
        layouts.append(layout_info)
    
    return layouts

# ============================================================================
# THEME EXTRACTION
# ============================================================================

def extract_theme_colors(master_or_prs, warnings: List[str]) -> Dict[str, str]:
    """
    Extract theme colors from presentation or master using proper color scheme API.
    
    Args:
        master_or_prs: Presentation or SlideMaster object
        warnings: List to append warnings to
        
    Returns:
        Dict mapping color names to hex codes or scheme references
    """
    colors = {}
    
    try:
        # Handle both Presentation (use first master) and SlideMaster objects
        if hasattr(master_or_prs, 'slide_masters'):
            if len(master_or_prs.slide_masters) == 0:
                warnings.append("No slide masters found")
                return {}
            slide_master = master_or_prs.slide_masters[0]
        else:
            slide_master = master_or_prs

        theme = getattr(slide_master, 'theme', None)
        if not theme:
            warnings.append("Theme object unavailable")
            return {}
            
        color_scheme = getattr(theme, 'theme_color_scheme', None)
        if not color_scheme:
            warnings.append("Theme color scheme unavailable")
            return {}
        
        color_attrs = [
            'accent1', 'accent2', 'accent3', 'accent4', 'accent5', 'accent6',
            'background1', 'background2', 'text1', 'text2', 
            'hyperlink', 'followed_hyperlink'
        ]
        
        non_rgb_found = False
        for color_name in color_attrs:
            try:
                color = getattr(color_scheme, color_name, None)
                if color:
                    if hasattr(color, 'r') and hasattr(color, 'g') and hasattr(color, 'b'):
                        colors[color_name] = rgb_to_hex(color)
                    else:
                        colors[color_name] = f"schemeColor:{color_name}"
                        non_rgb_found = True
            except Exception:
                pass
        
        if not colors:
            warnings.append("Theme color scheme unavailable or empty")
        elif non_rgb_found:
            warnings.append("Theme colors include non-RGB scheme references")
            
    except Exception as e:
        warnings.append(f"Theme color extraction failed: {str(e)}")
    
    return colors


def _font_name(font_obj) -> Optional[str]:
    """
    Helper to safely get typeface from font object.
    
    Args:
        font_obj: Font object from python-pptx
        
    Returns:
        Font name string or None
    """
    if font_obj is None:
        return None
    return getattr(font_obj, 'typeface', str(font_obj)) if font_obj else None


def extract_theme_fonts(master_or_prs, warnings: List[str]) -> Dict[str, str]:
    """
    Extract theme fonts from presentation or master using proper font scheme API.
    
    Args:
        master_or_prs: Presentation or SlideMaster object
        warnings: List to append warnings to
        
    Returns:
        Dict with heading and body font names
    """
    fonts = {}
    fallback_used = False
    
    try:
        # Handle both Presentation (use first master) and SlideMaster objects
        if hasattr(master_or_prs, 'slide_masters'):
            if len(master_or_prs.slide_masters) == 0:
                fallback_used = True
                fonts = {"heading": "Calibri", "body": "Calibri"}
                warnings.append("No slide masters found - using default fonts")
                return fonts
            slide_master = master_or_prs.slide_masters[0]
        else:
            slide_master = master_or_prs

        theme = getattr(slide_master, 'theme', None)
        
        if theme:
            font_scheme = getattr(theme, 'font_scheme', None)
            if font_scheme:
                major = getattr(font_scheme, 'major_font', None)
                minor = getattr(font_scheme, 'minor_font', None)
                
                if major:
                    latin = getattr(major, 'latin', None)
                    ea = getattr(major, 'east_asian', None)
                    cs = getattr(major, 'complex_script', None)
                    
                    heading_font = _font_name(latin) or _font_name(ea) or _font_name(cs)
                    if heading_font:
                        fonts['heading'] = heading_font
                    
                    if ea and _font_name(ea):
                        fonts['heading_east_asian'] = _font_name(ea)
                    if cs and _font_name(cs):
                        fonts['heading_complex'] = _font_name(cs)
                
                if minor:
                    latin = getattr(minor, 'latin', None)
                    ea = getattr(minor, 'east_asian', None)
                    cs = getattr(minor, 'complex_script', None)
                    
                    body_font = _font_name(latin) or _font_name(ea) or _font_name(cs)
                    if body_font:
                        fonts['body'] = body_font
                    
                    if ea and _font_name(ea):
                        fonts['body_east_asian'] = _font_name(ea)
                    if cs and _font_name(cs):
                        fonts['body_complex'] = _font_name(cs)

        # Fallback: detect from shapes if theme API failed
        if not fonts:
            for shape in slide_master.shapes:
                if hasattr(shape, 'text_frame') and shape.text_frame:
                    try:
                        for paragraph in shape.text_frame.paragraphs:
                            if paragraph.font.name and 'heading' not in fonts:
                                fonts['heading'] = paragraph.font.name
                                break
                    except Exception:
                        pass
                if 'heading' in fonts:
                    break
        
        if not fonts:
            fallback_used = True
            fonts = {"heading": "Calibri", "body": "Calibri"}
            
    except Exception as e:
        fallback_used = True
        fonts = {"heading": "Calibri", "body": "Calibri"}
        warnings.append(f"Theme font extraction failed: {str(e)}")
    
    if fallback_used and hasattr(master_or_prs, 'slide_masters'):
        warnings.append("Theme fonts unavailable - using Calibri defaults")
    
    return fonts

# ============================================================================
# CAPABILITY ANALYSIS
# ============================================================================

def analyze_capabilities(layouts: List[Dict[str, Any]], prs) -> Dict[str, Any]:
    """
    Analyze template capabilities based on detected layouts.
    
    Args:
        layouts: List of layout information dicts
        prs: Presentation object
        
    Returns:
        Dict with capability flags, layout mappings, and recommendations
    """
    has_footer = False
    has_slide_number = False
    has_date = False
    layouts_with_footer = []
    layouts_with_slide_number = []
    layouts_with_date = []
    
    # Find type codes for footer, slide number, date
    footer_type_code = None
    slide_number_type_code = None
    date_type_code = None
    
    for type_code, type_name in PLACEHOLDER_TYPE_MAP.items():
        if type_name == 'FOOTER':
            footer_type_code = type_code
        elif type_name == 'SLIDE_NUMBER':
            slide_number_type_code = type_code
        elif type_name == 'DATE':
            date_type_code = type_code
    
    per_master_stats = {}
    
    for layout in layouts:
        layout_ref = {
            "index": layout['index'],
            "original_index": layout.get('original_index', layout['index']),
            "name": layout['name'],
            "master_index": layout.get('master_index')
        }
        m_idx = layout.get('master_index')
        
        if m_idx is not None:
            if m_idx not in per_master_stats:
                per_master_stats[m_idx] = {
                    "master_index": m_idx,
                    "layout_count": 0,
                    "has_footer_layouts": 0,
                    "has_slide_number_layouts": 0,
                    "has_date_layouts": 0
                }
            per_master_stats[m_idx]["layout_count"] += 1
        
        layout_has_footer = False
        layout_has_slide_number = False
        layout_has_date = False

        # Check placeholders for capability types
        if 'placeholders' in layout:
            for ph in layout['placeholders']:
                ph_type_code = ph.get('type_code')
                
                if footer_type_code is not None and ph_type_code == footer_type_code:
                    has_footer = True
                    layout_has_footer = True
                    if layout_ref not in layouts_with_footer:
                        layouts_with_footer.append(layout_ref)
                
                if slide_number_type_code is not None and ph_type_code == slide_number_type_code:
                    has_slide_number = True
                    layout_has_slide_number = True
                    if layout_ref not in layouts_with_slide_number:
                        layouts_with_slide_number.append(layout_ref)
                
                if date_type_code is not None and ph_type_code == date_type_code:
                    has_date = True
                    layout_has_date = True
                    if layout_ref not in layouts_with_date:
                        layouts_with_date.append(layout_ref)
                        
        elif 'placeholder_types' in layout:
            # Fallback to type names if detailed placeholders not available
            if 'FOOTER' in layout['placeholder_types']:
                has_footer = True
                layout_has_footer = True
                if layout_ref not in layouts_with_footer:
                    layouts_with_footer.append(layout_ref)
            
            if 'SLIDE_NUMBER' in layout['placeholder_types']:
                has_slide_number = True
                layout_has_slide_number = True
                if layout_ref not in layouts_with_slide_number:
                    layouts_with_slide_number.append(layout_ref)
            
            if 'DATE' in layout['placeholder_types']:
                has_date = True
                layout_has_date = True
                if layout_ref not in layouts_with_date:
                    layouts_with_date.append(layout_ref)
        
        # Update per-master stats
        if m_idx is not None:
            if layout_has_footer:
                per_master_stats[m_idx]["has_footer_layouts"] += 1
            if layout_has_slide_number:
                per_master_stats[m_idx]["has_slide_number_layouts"] += 1
            if layout_has_date:
                per_master_stats[m_idx]["has_date_layouts"] += 1
    
    # Generate recommendations
    recommendations = []
    
    if not has_footer:
        recommendations.append(
            "No footer placeholders found - ppt_set_footer.py will use text box fallback strategy"
        )
    else:
        layout_names = [l['name'] for l in layouts_with_footer]
        recommendations.append(
            f"Footer placeholders available on {len(layouts_with_footer)} layout(s): {', '.join(layout_names)}"
        )
    
    if not has_slide_number:
        recommendations.append(
            "No slide number placeholders - recommend manual text box for slide numbers"
        )
    else:
        layout_names = [l['name'] for l in layouts_with_slide_number]
        recommendations.append(
            f"Slide number placeholders available on {len(layouts_with_slide_number)} layout(s): {', '.join(layout_names)}"
        )
    
    if not has_date:
        recommendations.append(
            "No date placeholders - dates must be added manually if needed"
        )
    else:
        layout_names = [l['name'] for l in layouts_with_date]
        recommendations.append(
            f"Date placeholders available on {len(layouts_with_date)} layout(s): {', '.join(layout_names)}"
        )
    
    return {
        "has_footer_placeholders": has_footer,
        "has_slide_number_placeholders": has_slide_number,
        "has_date_placeholders": has_date,
        "layouts_with_footer": layouts_with_footer,
        "layouts_with_slide_number": layouts_with_slide_number,
        "layouts_with_date": layouts_with_date,
        "total_layouts": len(layouts),
        "total_master_slides": len(prs.slide_masters),
        "per_master": list(per_master_stats.values()),
        "footer_support_mode": "placeholder" if has_footer else "fallback_textbox",
        "slide_number_strategy": "placeholder" if has_slide_number else "textbox",
        "recommendations": recommendations
    }

# ============================================================================
# OUTPUT VALIDATION
# ============================================================================

def validate_output(result: Dict[str, Any]) -> Tuple[bool, List[str]]:
    """
    Validate probe result has all required fields.
    
    Args:
        result: Probe result dict
        
    Returns:
        Tuple of (is_valid, list of missing fields)
    """
    required_fields = [
        "status",
        "metadata",
        "metadata.file",
        "metadata.probed_at",
        "metadata.tool_version",
        "metadata.operation_id",
        "metadata.duration_ms",
        "slide_dimensions",
        "layouts",
        "theme",
        "capabilities",
        "warnings"
    ]
    
    missing = []
    
    for field_path in required_fields:
        parts = field_path.split('.')
        current = result
        
        found = True
        for part in parts:
            if not isinstance(current, dict) or part not in current:
                found = False
                break
            current = current[part]
        
        if not found:
            missing.append(field_path)
    
    return (len(missing) == 0, missing)

# ============================================================================
# MAIN PROBE FUNCTION
# ============================================================================

def probe_presentation(
    filepath: Path,
    deep: bool = False,
    verify_atomic: bool = True,
    max_layouts: Optional[int] = None,
    timeout_seconds: Optional[int] = None
) -> Dict[str, Any]:
    """
    Probe presentation and return comprehensive capability report.
    
    Implements the 3-layer probe resilience pattern:
    - Layer 1: Timeout protection
    - Layer 2: Transient slide instantiation
    - Layer 3: Graceful degradation with partial results
    
    Args:
        filepath: Path to PowerPoint file
        deep: If True, perform deep analysis with transient slide instantiation
        verify_atomic: If True, verify no file mutation occurred
        max_layouts: Maximum layouts to analyze (None = DEFAULT_MAX_LAYOUTS)
        timeout_seconds: Maximum seconds for analysis (None = DEFAULT_TIMEOUT_SECONDS)
        
    Returns:
        Dict with complete capability report
        
    Raises:
        FileNotFoundError: If file doesn't exist
        PermissionError: If file is locked or inaccessible
        PowerPointAgentError: If atomic verification fails
    """
    # Validate inputs
    if not filepath.exists():
        raise FileNotFoundError(f"File not found: {filepath}")
    
    if not filepath.is_file():
        raise ValueError(f"Path is not a file: {filepath}")
    
    # Check file accessibility
    try:
        with open(filepath, 'rb') as f:
            f.read(1)
    except PermissionError:
        raise PermissionError(f"File is locked or permission denied: {filepath}")
    
    # Apply defaults
    if timeout_seconds is None:
        timeout_seconds = DEFAULT_TIMEOUT_SECONDS
    if max_layouts is None:
        max_layouts = DEFAULT_MAX_LAYOUTS
    
    # Initialize tracking
    start_time = time.perf_counter()
    operation_id = str(uuid.uuid4())
    warnings = []
    info = []
    
    # Atomic verification: capture checksum before
    checksum_before = None
    if verify_atomic:
        checksum_before = calculate_file_checksum(filepath)
    
    # Check library availability
    if not PPTX_AVAILABLE:
        raise ImportError("python-pptx library is not installed")
    
    # Load presentation
    prs = Presentation(str(filepath))
    
    # Extract dimensions
    dimensions = detect_slide_dimensions(prs)
    slide_width = dimensions['width_inches']
    slide_height = dimensions['height_inches']
    
    # Track layout counts
    all_layouts = list(prs.slide_layouts)
    if max_layouts and len(all_layouts) > max_layouts:
        info.append(f"Limited analysis to first {max_layouts} of {len(all_layouts)} layouts")
    
    # Detect layouts with optional deep analysis
    layouts = detect_layouts_with_instantiation(
        prs, 
        slide_width, 
        slide_height, 
        deep, 
        warnings, 
        timeout_start=start_time, 
        timeout_seconds=timeout_seconds,
        max_layouts=max_layouts
    )
    
    # Layer 3: Check if analysis was complete
    analysis_complete = True
    elapsed = time.perf_counter() - start_time
    if elapsed > timeout_seconds:
        analysis_complete = False
        info.append(f"Analysis timed out after {elapsed:.2f}s")
    
    # Extract theme info from primary master
    theme_colors = extract_theme_colors(prs, warnings)
    theme_fonts = extract_theme_fonts(prs, warnings)
    
    # Extract per-master theme info
    theme_per_master = []
    try:
        for m_idx, master in enumerate(prs.slide_masters):
            master_warnings = []
            m_colors = extract_theme_colors(master, master_warnings)
            m_fonts = extract_theme_fonts(master, master_warnings)
            theme_per_master.append({
                "master_index": m_idx,
                "colors": m_colors,
                "fonts": m_fonts
            })
    except Exception:
        pass
    
    # Analyze capabilities
    capabilities = analyze_capabilities(layouts, prs)
    capabilities["analysis_complete"] = analysis_complete
    
    # Calculate duration
    duration_ms = int((time.perf_counter() - start_time) * 1000)
    
    # Atomic verification: compare checksums
    checksum_after = None
    atomic_verified = False
    if verify_atomic:
        checksum_after = calculate_file_checksum(filepath)
        atomic_verified = (checksum_before == checksum_after)
        
        if not atomic_verified:
            raise PowerPointAgentError(
                "File was modified during probe operation! "
                "This should never happen (atomic read violation). "
                f"Checksum before: {checksum_before}, after: {checksum_after}"
            )
    
    # Build master metadata
    masters_metadata = []
    try:
        for m_idx, m in enumerate(prs.slide_masters):
            master_info = {
                "master_index": m_idx,
                "layout_count": len(m.slide_layouts),
                "name": getattr(m, 'name', f"Master {m_idx}")
            }
            if hasattr(m, 'rId'):
                master_info["rId"] = m.rId
            masters_metadata.append(master_info)
    except Exception:
        pass
    
    # Construct result
    result = {
        "status": "success",
        "metadata": {
            "file": str(filepath.resolve()),
            "probed_at": datetime.now().isoformat(),
            "tool_version": __version__,
            "schema_version": SCHEMA_VERSION,
            "operation_id": operation_id,
            "deep_analysis": deep,
            "analysis_mode": "deep" if deep else "essential",
            "atomic_verified": verify_atomic and atomic_verified,
            "duration_ms": duration_ms,
            "timeout_seconds": timeout_seconds,
            "layout_count_total": len(all_layouts),
            "layout_count_analyzed": len(layouts),
            "warnings_count": len(warnings),
            "masters": masters_metadata,
            "library_versions": get_library_versions(),
            "checksum": checksum_before if verify_atomic else "verification_skipped"
        },
        "slide_dimensions": dimensions,
        "layouts": layouts,
        "theme": {
            "colors": theme_colors,
            "fonts": theme_fonts,
            "per_master": theme_per_master
        },
        "capabilities": capabilities,
        "warnings": warnings,
        "info": info
    }
    
    # Internal validation
    is_valid, missing_fields = validate_output(result)
    if not is_valid:
        result["status"] = "warning"
        warnings.append(f"Output validation found missing fields: {', '.join(missing_fields)}")
    
    # Strict schema validation (optional, graceful if schema missing)
    if STRICT_VALIDATOR_AVAILABLE:
        try:
            schema_path = Path(__file__).parent.parent / "schemas" / "capability_probe.v3.1.0.schema.json"
            if schema_path.exists():
                validate_against_schema(result, str(schema_path))
        except FileNotFoundError:
            info.append("Schema file not found - skipping strict validation")
        except Exception as e:
            warnings.append(f"Strict schema validation failed: {str(e)}")
    
    return result

# ============================================================================
# HUMAN-READABLE SUMMARY
# ============================================================================

def format_summary(probe_result: Dict[str, Any]) -> str:
    """
    Format probe result as human-readable summary.
    
    Args:
        probe_result: Result from probe_presentation()
        
    Returns:
        Formatted string summary
    """
    lines = []
    
    lines.append("═══════════════════════════════════════════════════════════════")
    lines.append(f"PowerPoint Capability Probe Report v{__version__}")
    lines.append("═══════════════════════════════════════════════════════════════")
    lines.append("")
    
    meta = probe_result.get('metadata', {})
    lines.append(f"File: {meta.get('file', 'unknown')}")
    lines.append(f"Probed: {meta.get('probed_at', 'unknown')}")
    lines.append(f"Operation ID: {meta.get('operation_id', 'unknown')}")
    lines.append(f"Analysis Mode: {'Deep (instantiated positions)' if meta.get('deep_analysis') else 'Essential (template positions)'}")
    lines.append(f"Duration: {meta.get('duration_ms', 0)}ms")
    lines.append(f"Atomic Verified: {'✓' if meta.get('atomic_verified') else '✗'}")
    lines.append("")
    
    lib_versions = meta.get('library_versions', {})
    if lib_versions:
        lines.append("Library Versions:")
        for lib, ver in lib_versions.items():
            lines.append(f"  {lib}: {ver}")
        lines.append("")
    
    dims = probe_result.get('slide_dimensions', {})
    if dims:
        lines.append("Slide Dimensions:")
        lines.append(f"  Size: {dims.get('width_inches', 0)}\" × {dims.get('height_inches', 0)}\" ({dims.get('width_pixels', 0)}×{dims.get('height_pixels', 0)}px)")
        lines.append(f"  Aspect Ratio: {dims.get('aspect_ratio', 'unknown')}")
        lines.append(f"  DPI Estimate: {dims.get('dpi_estimate', 96)}")
        lines.append("")
    
    caps = probe_result.get('capabilities', {})
    if caps:
        lines.append("Template Capabilities:")
        lines.append(f"  ✓ Total Layouts: {caps.get('total_layouts', 0)}")
        lines.append(f"  ✓ Master Slides: {caps.get('total_master_slides', 0)}")
        lines.append(f"  {'✓' if caps.get('has_footer_placeholders') else '✗'} Footer Placeholders: {len(caps.get('layouts_with_footer', []))} layout(s)")
        lines.append(f"  {'✓' if caps.get('has_slide_number_placeholders') else '✗'} Slide Number Placeholders: {len(caps.get('layouts_with_slide_number', []))} layout(s)")
        lines.append(f"  {'✓' if caps.get('has_date_placeholders') else '✗'} Date Placeholders: {len(caps.get('layouts_with_date', []))} layout(s)")
        lines.append("")

        per_master = caps.get('per_master', [])
        if per_master:
            lines.append("Master Slides:")
            for m in per_master:
                lines.append(f"  Master {m.get('master_index', '?')}: {m.get('layout_count', 0)} layouts")
                has_footer = 'Yes' if m.get('has_footer_layouts', 0) > 0 else 'No'
                has_slide_num = 'Yes' if m.get('has_slide_number_layouts', 0) > 0 else 'No'
                has_date = 'Yes' if m.get('has_date_layouts', 0) > 0 else 'No'
                lines.append(f"    Footer: {has_footer} | Slide #: {has_slide_num} | Date: {has_date}")
            lines.append("")
    
    layouts = probe_result.get('layouts', [])
    if layouts:
        lines.append("Available Layouts:")
        for layout in layouts:
            ph_count = layout.get('placeholder_count', 0)
            display_idx = layout.get('original_index', layout.get('index', 0))
            lines.append(f"  [{display_idx}] {layout.get('name', 'Unnamed')} ({ph_count} placeholder{'s' if ph_count != 1 else ''})")
            
            types = layout.get('placeholder_types', [])
            if types:
                lines.append(f"      Types: {', '.join(types)}")
        lines.append("")
    
    theme = probe_result.get('theme', {})
    fonts = theme.get('fonts', {})
    if fonts:
        lines.append("Theme Fonts:")
        for key, value in fonts.items():
            if not key.startswith('_'):
                lines.append(f"  {key.replace('_', ' ').title()}: {value}")
        lines.append("")
    
    colors = theme.get('colors', {})
    if colors:
        color_count = len([k for k in colors.keys() if not k.startswith('_')])
        lines.append(f"Theme Colors: {color_count} defined")
        lines.append("")
    
    recommendations = caps.get('recommendations', []) if caps else []
    if recommendations:
        lines.append("Recommendations:")
        for rec in recommendations:
            lines.append(f"  • {rec}")
        lines.append("")
    
    warnings = probe_result.get('warnings', [])
    if warnings:
        lines.append("⚠️  Warnings:")
        for warning in warnings:
            lines.append(f"  • {warning}")
        lines.append("")
    
    info_msgs = probe_result.get('info', [])
    if info_msgs:
        lines.append("ℹ️  Information:")
        for info_msg in info_msgs:
            lines.append(f"  • {info_msg}")
        lines.append("")
    
    lines.append("═══════════════════════════════════════════════════════════════")
    
    return "\n".join(lines)

# ============================================================================
# CLI INTERFACE
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description=f"Probe PowerPoint presentation capabilities (v{__version__})",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic probe (essential info, fast)
  uv run tools/ppt_capability_probe.py --file template.pptx --json
  
  # Deep probe (accurate positions via transient instantiation)
  uv run tools/ppt_capability_probe.py --file template.pptx --deep --json
  
  # Human-friendly summary
  uv run tools/ppt_capability_probe.py --file template.pptx --summary
  
  # Skip atomic verification for speed
  uv run tools/ppt_capability_probe.py --file template.pptx --no-verify-atomic --json
  
  # Large template with layout limit and custom timeout
  uv run tools/ppt_capability_probe.py --file big_template.pptx --max-layouts 20 --timeout 30 --json
        """
    )
    
    parser.add_argument(
        '--file',
        required=True,
        type=Path,
        help='PowerPoint file to probe'
    )
    
    parser.add_argument(
        '--deep',
        action='store_true',
        help='Perform deep analysis with transient slide instantiation for accurate positions (slower)'
    )
    
    parser.add_argument(
        '--summary',
        action='store_true',
        help='Output human-friendly summary instead of JSON'
    )
    
    parser.add_argument(
        '--verify-atomic',
        action='store_true',
        default=True,
        dest='verify_atomic',
        help='Verify no file mutation occurred (default: true)'
    )
    
    parser.add_argument(
        '--no-verify-atomic',
        action='store_false',
        dest='verify_atomic',
        help='Skip atomic verification (faster, less safe)'
    )
    
    parser.add_argument(
        '--max-layouts',
        type=int,
        default=DEFAULT_MAX_LAYOUTS,
        help=f'Maximum layouts to analyze (default: {DEFAULT_MAX_LAYOUTS})'
    )

    parser.add_argument(
        '--timeout',
        type=int,
        default=DEFAULT_TIMEOUT_SECONDS,
        help=f'Timeout in seconds for analysis (default: {DEFAULT_TIMEOUT_SECONDS})'
    )
    
    parser.add_argument(
        '--json',
        action='store_true',
        dest='output_json',
        help='Output JSON format (default if --summary not specified)'
    )
    
    args = parser.parse_args()
    
    # Default to JSON if neither format specified
    if not args.summary and not args.output_json:
        args.output_json = True
        
    if args.summary and args.output_json:
        error_result = {
            "status": "error",
            "error": "Cannot use both --summary and --json",
            "error_type": "ArgumentError",
            "suggestion": "Choose either --summary for human output or --json for machine output"
        }
        sys.stdout.write(json.dumps(error_result, indent=2) + "\n")
        sys.exit(1)
    
    try:
        result = probe_presentation(
            filepath=args.file,
            deep=args.deep,
            verify_atomic=args.verify_atomic,
            max_layouts=args.max_layouts,
            timeout_seconds=args.timeout
        )
        
        if args.summary:
            sys.stdout.write(format_summary(result) + "\n")
        else:
            sys.stdout.write(json.dumps(result, indent=2) + "\n")
        
        sys.exit(0)
        
    except FileNotFoundError as e:
        error_result = {
            "status": "error",
            "error": str(e),
            "error_type": "FileNotFoundError",
            "metadata": {
                "file": str(args.file),
                "tool_version": __version__,
                "operation_id": str(uuid.uuid4()),
                "probed_at": datetime.now().isoformat()
            },
            "suggestion": "Verify the file path exists and is accessible"
        }
        sys.stdout.write(json.dumps(error_result, indent=2) + "\n")
        sys.exit(1)
        
    except PermissionError as e:
        error_result = {
            "status": "error",
            "error": str(e),
            "error_type": "PermissionError",
            "metadata": {
                "file": str(args.file),
                "tool_version": __version__,
                "operation_id": str(uuid.uuid4()),
                "probed_at": datetime.now().isoformat()
            },
            "suggestion": "Check if the file is locked by another process or if you have read permissions"
        }
        sys.stdout.write(json.dumps(error_result, indent=2) + "\n")
        sys.exit(1)
        
    except Exception as e:
        error_result = {
            "status": "error",
            "error": str(e),
            "error_type": type(e).__name__,
            "metadata": {
                "file": str(args.file) if args.file else None,
                "tool_version": __version__,
                "operation_id": str(uuid.uuid4()),
                "probed_at": datetime.now().isoformat()
            },
            "warnings": []
        }
        sys.stdout.write(json.dumps(error_result, indent=2) + "\n")
        sys.exit(1)


if __name__ == "__main__":
    main()
